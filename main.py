# main.py
# Clean DATRIX Bot + Web Dashboard (No Broadcast)

import os
import logging
import threading
from datetime import datetime
from flask import Flask, render_template, request, jsonify
from functools import wraps
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes
import database as db

# Logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', 
    level=logging.INFO,
    handlers=[
        logging.FileHandler('datrix.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Configuration
BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN', '7803291138:AAExEBQq9uZhq6X_ncI_c8E2J80-tpZtq8E')
ADMIN_CHAT_ID = os.environ.get('ADMIN_TELEGRAM_ID', '811896458')
WEB_USER = os.environ.get('WEB_USER', 'admin')
WEB_PASS = os.environ.get('WEB_PASS', 'datrix2024')

# Global variable to store current file info
CURRENT_FILE = {
    'file_id': None,
    'version': 'v2.1.6',
    'size': 'Unknown',
    'filename': 'DATRIX_Setup.exe',
    'upload_date': None
}

# =================== FLASK WEB APP ===================
web_app = Flask(__name__)

def check_auth(username, password): 
    return username == WEB_USER and password == WEB_PASS

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            return ('Unauthorized', 401, {'WWW-Authenticate': 'Basic realm="DATRIX Control Panel"'})
        return f(*args, **kwargs)
    return decorated_function

@web_app.route('/')
@login_required
def dashboard(): 
    # Try to load template, fallback to embedded HTML
    try:
        return render_template('dashboard.html')
    except:
        # Embedded dashboard if template not found
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>DATRIX Control Panel</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: #f8f9fa; }
                .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
                .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 12px; margin-bottom: 30px; text-align: center; }
                .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
                .header p { opacity: 0.9; font-size: 1.1rem; }
                .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
                .stat { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }
                .stat h3 { font-size: 2rem; margin-bottom: 5px; color: #333; }
                .stat p { color: #666; font-weight: 500; }
                .stat.users h3 { color: #3498db; }
                .stat.active h3 { color: #2ecc71; }
                .stat.licensed h3 { color: #e74c3c; }
                .stat.downloads h3 { color: #f39c12; }
                .section { background: white; border-radius: 12px; padding: 25px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                .section h2 { margin-bottom: 20px; color: #333; }
                .table { width: 100%; border-collapse: collapse; }
                .table th, .table td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; }
                .table th { background: #f8f9fa; font-weight: 600; }
                .table tr:hover { background: #f8f9fa; }
                .btn { background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; }
                .btn:hover { background: #2980b9; }
                .btn.success { background: #2ecc71; }
                .btn.success:hover { background: #27ae60; }
                .status.active { color: #2ecc71; font-weight: 600; }
                .status.expired { color: #e74c3c; font-weight: 600; }
                .loading { text-align: center; padding: 50px; color: #666; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>ü§ñ DATRIX Control Panel</h1>
                    <p>Bot Management & User Analytics Dashboard</p>
                </div>
                
                <div class="stats">
                    <div class="stat users">
                        <h3 id="totalUsers">-</h3>
                        <p>Total Users</p>
                    </div>
                    <div class="stat active">
                        <h3 id="activeUsers">-</h3>
                        <p>Active Users (24h)</p>
                    </div>
                    <div class="stat licensed">
                        <h3 id="licensedUsers">-</h3>
                        <p>Licensed Users</p>
                    </div>
                    <div class="stat downloads">
                        <h3 id="downloads">-</h3>
                        <p>Total Downloads</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üìã Users Management</h2>
                    <div id="usersContainer">
                        <div class="loading">Loading users data...</div>
                    </div>
                </div>
            </div>
            
            <script>
                // Load stats
                fetch('/api/bot_stats')
                    .then(r => r.json())
                    .then(data => {
                        document.getElementById('totalUsers').textContent = data.total_users || 0;
                        document.getElementById('activeUsers').textContent = data.active_users || 0;
                        document.getElementById('licensedUsers').textContent = data.licensed_users || 0;
                        document.getElementById('downloads').textContent = data.downloads_today || 0;
                    })
                    .catch(e => console.error('Error loading stats:', e));
                
                // Load users
                fetch('/api/datrix_users')
                    .then(r => r.json())
                    .then(users => {
                        const container = document.getElementById('usersContainer');
                        
                        if (users.length === 0) {
                            container.innerHTML = '<div class="loading">No users found</div>';
                            return;
                        }
                        
                        const table = `
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>User ID</th>
                                        <th>Name</th>
                                        <th>Company</th>
                                        <th>License Status</th>
                                        <th>Downloads</th>
                                        <th>Last Seen</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${users.map(user => `
                                        <tr>
                                            <td>${user.telegram_id}</td>
                                            <td>${user.user_name || 'Unknown'}</td>
                                            <td>${user.company_name || 'Not set'}</td>
                                            <td class="status ${user.is_app_user ? 'active' : 'expired'}">
                                                ${user.is_app_user ? '‚úÖ Active' : '‚ùå Expired'}
                                            </td>
                                            <td>${user.total_downloads || 0}</td>
                                            <td>${user.last_seen_formatted || 'Never'}</td>
                                            <td>
                                                <button class="btn" onclick="extendLicense(${user.telegram_id}, 30)">+30d</button>
                                                <button class="btn success" onclick="extendLicense(${user.telegram_id}, 90)">+90d</button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        `;
                        
                        container.innerHTML = table;
                    })
                    .catch(e => {
                        console.error('Error loading users:', e);
                        document.getElementById('usersContainer').innerHTML = '<div class="loading">Error loading users</div>';
                    });
                
                function extendLicense(userId, days) {
                    if (!confirm(`Extend license for user ${userId} by ${days} days?`)) return;
                    
                    fetch('/api/extend_license', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({user_id: userId, days: days})
                    })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            alert('License extended successfully!');
                            location.reload();
                        } else {
                            alert('Error: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(e => {
                        alert('Network error: ' + e.message);
                    });
                }
                
                // Refresh data every 30 seconds
                setInterval(() => {
                    location.reload();
                }, 30000);
            </script>
        </body>
        </html>
        """
@web_app.route('/api/extend_license', methods=['POST'])
@login_required
def api_extend_license():
    try:
        data = request.json
        user_id = data.get('user_id')
        days = data.get('days', 30)
        
        if not user_id:
            return jsonify({'error': 'User ID required'}), 400
            
        success = db.extend_user_license(user_id, days)
        
        if success:
            return jsonify({
                'success': True, 
                'message': f'License extended by {days} days'
            })
        else:
            return jsonify({'error': 'Failed to extend license'}), 500
    except Exception as e:
        logger.error(f"Error extending license: {e}")
        return jsonify({'error': str(e)}), 500

@web_app.route('/api/file_info')
@login_required
def api_file_info():
    """Get current file info"""
    return jsonify(CURRENT_FILE)

@web_app.route('/api/bot_stats')
@login_required
def api_bot_stats():
    """Get basic bot statistics"""
    try:
        stats = db.get_basic_stats()
        return jsonify(stats)
    except Exception as e:
        logger.error(f"Error getting stats: {e}")
        return jsonify({
            'total_users': 0,
            'active_users': 0,
            'downloads_today': 0,
            'licensed_users': 0
        })

# Original compatibility routes (empty implementations)
@web_app.route('/api/bot_users')
@login_required
def api_bot_users(): 
    return api_datrix_users()

# =================== TELEGRAM BOT ===================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    
    # Register user
    db.add_or_update_user(user.id, user.username, user.first_name)
    db.log_user_activity(user.id, 'start', 'User started bot')
    
    welcome_message = """ü§ñ **ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ ŸÅŸä DATRIX Bot**

üìã **ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:**
‚Ä¢ `/datrix_app` - ÿ™ÿ≠ŸÖŸäŸÑ ÿ™ÿ∑ÿ®ŸäŸÇ DATRIX
‚Ä¢ `/register_company` - ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¥ÿ±ŸÉÿ™ŸÉ
‚Ä¢ `/request_license` - ÿ∑ŸÑÿ® ÿ™ÿ±ÿÆŸäÿµ ÿ¨ÿØŸäÿØ
‚Ä¢ `/my_status` - ÿ≠ÿßŸÑÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ
‚Ä¢ `/help` - ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©

üåê **ŸäÿπŸÖŸÑ 24/7 ÿπŸÑŸâ ÿßŸÑÿÆÿßÿØŸÖ ÿßŸÑÿ≥ÿ≠ÿßÿ®Ÿä**
‚ö° **ÿ™ÿ≠ŸÖŸäŸÑ ŸÅŸàÿ±Ÿä ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÖŸÜ ÿßŸÑÿ®Ÿàÿ™**

üí° **ŸÑŸÑÿ®ÿØÿ°:** ÿßÿ≥ÿ™ÿÆÿØŸÖ `/register_company` ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¥ÿ±ŸÉÿ™ŸÉ"""
    
    await update.message.reply_text(welcome_message, parse_mode='Markdown')
    logger.info(f"‚úÖ User {user.id} started the bot")

async def register_company(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    
    if len(context.args) < 2:
        await update.message.reply_text(
            "üìù **ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ±:**\n"
            "`/register_company \"ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©\" google_sheet_id`\n\n"
            "**ŸÖÿ´ÿßŸÑ:**\n"
            "`/register_company \"ÿ¥ÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ\" 1OTNGDMgnVdkhqN9t2ESvuXA`",
            parse_mode='Markdown'
        )
        return
    
    # Parse company name (may have quotes)
    args_text = ' '.join(context.args)
    if args_text.startswith('"'):
        # Extract quoted company name
        end_quote = args_text.find('"', 1)
        if end_quote != -1:
            company_name = args_text[1:end_quote]
            remaining = args_text[end_quote+1:].strip()
            sheet_id = remaining.split()[0] if remaining.split() else None
        else:
            company_name = context.args[0]
            sheet_id = context.args[1] if len(context.args) > 1 else None
    else:
        company_name = context.args[0]
        sheet_id = context.args[1] if len(context.args) > 1 else None
    
    if not sheet_id:
        await update.message.reply_text("‚ùå **Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ Google Sheet ID**", parse_mode='Markdown')
        return
    
    # Update user info
    success = db.update_user_company(user.id, company_name, sheet_id)
    
    if success:
        db.log_user_activity(user.id, 'register_company', f'{company_name} - {sheet_id}')
        
        await update.message.reply_text(
            f"‚úÖ **ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿ±ŸÉÿ©!**\n\n"
            f"üè¢ **ÿßŸÑÿ¥ÿ±ŸÉÿ©:** {company_name}\n"
            f"üìä **Sheet ID:** `{sheet_id}`\n\n"
            f"üí° ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ∑ŸÑÿ® ÿ™ÿ±ÿÆŸäÿµ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ `/request_license`",
            parse_mode='Markdown'
        )
        
        # Notify admin
        admin_msg = f"""üÜï **ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¥ÿ±ŸÉÿ© ÿ¨ÿØŸäÿØÿ©**
üë§ {user.first_name} (@{user.username})
üÜî `{user.id}`
üè¢ {company_name}
üìä `{sheet_id}`
üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M')}"""
        
        try:
            await context.bot.send_message(ADMIN_CHAT_ID, admin_msg, parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Failed to notify admin: {e}")
    else:
        await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")

async def request_license(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = db.get_user_info(user.id)
    
    if not user_info or not user_info.get('company_name'):
        await update.message.reply_text(
            "‚ùå **Ÿäÿ¨ÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿ£ŸàŸÑÿßŸã**\n\n"
            "ÿßÿ≥ÿ™ÿÆÿØŸÖ: `/register_company \"ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©\" sheet_id`",
            parse_mode='Markdown'
        )
        return
    
    db.log_user_activity(user.id, 'request_license', f"Company: {user_info['company_name']}")
    
    # Create admin keyboard
    keyboard = [
        [
            InlineKeyboardButton("ŸÖŸÜÿ≠ 30 ŸäŸàŸÖ", callback_data=f"extend_30:{user.id}"),
            InlineKeyboardButton("ŸÖŸÜÿ≠ 90 ŸäŸàŸÖ", callback_data=f"extend_90:{user.id}"),
        ],
        [
            InlineKeyboardButton("ŸÖŸÜÿ≠ ÿ≥ŸÜÿ©", callback_data=f"extend_365:{user.id}"),
            InlineKeyboardButton("ÿ±ŸÅÿ∂", callback_data=f"extend_deny:{user.id}"),
        ]
    ]
    markup = InlineKeyboardMarkup(keyboard)
    
    admin_msg = f"""üîë **ÿ∑ŸÑÿ® ÿ™ŸÖÿØŸäÿØ ÿ™ÿ±ÿÆŸäÿµ DATRIX**

üë§ **ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:** {user.first_name} (@{user.username})
üÜî **Telegram ID:** `{user.id}`
üè¢ **ÿßŸÑÿ¥ÿ±ŸÉÿ©:** {user_info['company_name']}
üìä **Sheet ID:** `{user_info.get('google_sheet_id', 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ')}`
üìÖ **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ∑ŸÑÿ®:** {datetime.now().strftime('%Y-%m-%d %H:%M')}

‚è∞ **Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÅÿ™ÿ±ÿ© ÿßŸÑÿ™ŸÖÿØŸäÿØ:**"""
    
    try:
        await context.bot.send_message(ADMIN_CHAT_ID, admin_msg, reply_markup=markup, parse_mode='Markdown')
        await update.message.reply_text("‚úÖ **ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ® ÿßŸÑÿ™ŸÖÿØŸäÿØ ŸÑŸÑŸÖÿ±ÿßÿ¨ÿπÿ©**\n\nüìß ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ¥ÿπÿßÿ±ŸÉ ŸÅŸàÿ± ÿßŸÑŸÖŸàÿßŸÅŸÇÿ©", parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Failed to send license request: {e}")
        await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ®")

async def callback_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if str(query.from_user.id) != ADMIN_CHAT_ID:
        return
    
    data = query.data
    if data.startswith("extend_"):
        action, user_id_str = data.split(":", 1)
        user_id = int(user_id_str)
        
        if action == "extend_deny":
            await query.edit_message_text(f"‚ùå **ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿ∑ŸÑÿ® ÿßŸÑÿ™ÿ±ÿÆŸäÿµ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}**")
            try:
                await context.bot.send_message(user_id, "‚ùå **ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿ∑ŸÑÿ® ÿ™ŸÖÿØŸäÿØ ÿßŸÑÿ™ÿ±ÿÆŸäÿµ**\n\nŸäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ•ÿØÿßÿ±ÿ© ŸÑŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™.")
            except:
                pass
        else:
            days_map = {"extend_30": 30, "extend_90": 90, "extend_365": 365}
            days = days_map.get(action, 30)
            
            success = db.extend_user_license(user_id, days)
            
            if success:
                expiry_date = (datetime.now().date() + timedelta(days=days)).strftime('%Y-%m-%d')
                await query.edit_message_text(f"‚úÖ **ÿ™ŸÖ ŸÖŸÜÿ≠ ÿ™ÿ±ÿÆŸäÿµ {days} ŸäŸàŸÖ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}**\nüìÖ **ŸäŸÜÿ™ŸáŸä ŸÅŸä:** {expiry_date}")
                try:
                    await context.bot.send_message(
                        user_id,
                        f"üéâ **ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿ∑ŸÑÿ® ÿßŸÑÿ™ÿ±ÿÆŸäÿµ!**\n\n"
                        f"‚è∞ **ÿßŸÑŸÖÿØÿ© ÿßŸÑŸÖŸÖŸÜŸàÿ≠ÿ©:** {days} ŸäŸàŸÖ\n"
                        f"üìÖ **ŸäŸÜÿ™ŸáŸä ŸÅŸä:** {expiry_date}\n\n"
                        f"‚úÖ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ™ÿ≠ŸÖŸäŸÑ DATRIX ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ `/datrix_app`",
                        parse_mode='Markdown'
                    )
                except:
                    pass
            else:
                await query.edit_message_text(f"‚ùå **ŸÅÿ¥ŸÑ ŸÅŸä ŸÖŸÜÿ≠ ÿßŸÑÿ™ÿ±ÿÆŸäÿµ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}**")

async def my_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = db.get_user_info(user.id)
    
    if not user_info:
        await update.message.reply_text("‚ùå **ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ**\n\nÿßÿ≥ÿ™ÿÆÿØŸÖ `/start` ŸÑŸÑÿ™ÿ≥ÿ¨ŸäŸÑ", parse_mode='Markdown')
        return
    
    # Calculate license status
    license_text = "‚ö†Ô∏è ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ"
    if user_info.get('license_expires'):
        days_remaining = (user_info['license_expires'] - datetime.now().date()).days
        if days_remaining > 0:
            license_text = f"‚úÖ ŸÜÿ¥ÿ∑ ({days_remaining} ŸäŸàŸÖ ŸÖÿ™ÿ®ŸÇŸä)"
        else:
            license_text = f"‚ùå ŸÖŸÜÿ™ŸáŸä ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© ({abs(days_remaining)} ŸäŸàŸÖ)"
    
    status_msg = f"""üìä **ÿ≠ÿßŸÑÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ ŸÅŸä DATRIX**

üë§ **ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:** {user.first_name}
üÜî **Telegram ID:** `{user.id}`
üè¢ **ÿßŸÑÿ¥ÿ±ŸÉÿ©:** {user_info.get('company_name') or 'ÿ∫Ÿäÿ± ŸÖÿ≥ÿ¨ŸÑ'}
üìä **Sheet ID:** `{user_info.get('google_sheet_id') or 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}`

üîë **ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ±ÿÆŸäÿµ:** {license_text}
üìÖ **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ™ÿ±ÿÆŸäÿµ:** {user_info['license_expires'].strftime('%Y-%m-%d') if user_info.get('license_expires') else 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}
üì¶ **ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿßÿ™:** {user_info.get('download_count', 0)}
üìÖ **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ:** {user_info['created_at'].strftime('%Y-%m-%d') if user_info.get('created_at') else 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}

üí° **ÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©:**
‚Ä¢ `/request_license` - ÿ∑ŸÑÿ® ÿ™ŸÖÿØŸäÿØ ÿßŸÑÿ™ÿ±ÿÆŸäÿµ
‚Ä¢ `/datrix_app` - ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ™ÿ±ÿÆŸäÿµ ŸÜÿ¥ÿ∑)"""
    
    await update.message.reply_text(status_msg, parse_mode='Markdown')

async def get_datrix_app(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    
    # Check if user exists
    user_info = db.get_user_info(user.id)
    if not user_info:
        await update.message.reply_text("‚ùå **Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã**\nÿßÿ≥ÿ™ÿÆÿØŸÖ `/start`", parse_mode='Markdown')
        return
    
    # Check license
    if user_info.get('license_expires'):
        if user_info['license_expires'] <= datetime.now().date():
            await update.message.reply_text(
                "üîí **ÿßŸÑÿ™ÿ±ÿÆŸäÿµ ŸÖŸÜÿ™ŸáŸä ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©**\n\nÿßÿ≥ÿ™ÿÆÿØŸÖ `/request_license` ŸÑÿ∑ŸÑÿ® ÿ™ŸÖÿØŸäÿØ ÿßŸÑÿ™ÿ±ÿÆŸäÿµ",
                parse_mode='Markdown'
            )
            return
    else:
        await update.message.reply_text(
            "üîí **ŸÑÿß ŸäŸàÿ¨ÿØ ÿ™ÿ±ÿÆŸäÿµ ŸÜÿ¥ÿ∑**\n\nÿßÿ≥ÿ™ÿÆÿØŸÖ `/request_license` ŸÑÿ∑ŸÑÿ® ÿ™ÿ±ÿÆŸäÿµ ÿ¨ÿØŸäÿØ",
            parse_mode='Markdown'
        )
        return
    
    # Check if file is available
    if not CURRENT_FILE.get('file_id'):
        await update.message.reply_text("‚ùå **ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ÿ≠ÿßŸÑŸäÿßŸã**\n\nŸäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã ÿ£Ÿà ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ•ÿØÿßÿ±ÿ©", parse_mode='Markdown')
        return
    
    try:
        # Send the file directly
        await context.bot.send_document(
            chat_id=update.effective_chat.id,
            document=CURRENT_FILE['file_id'],
            caption=f"‚úÖ **{CURRENT_FILE['filename']}**\n\nüî¢ **ÿßŸÑÿ•ÿµÿØÿßÿ±:** {CURRENT_FILE['version']}\nüíæ **ÿßŸÑÿ≠ÿ¨ŸÖ:** {CURRENT_FILE['size']}\nüìÖ **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ±ŸÅÿπ:** {CURRENT_FILE['upload_date']}\n\nüöÄ **ÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ DATRIX!**"
        )
        
        # Track download
        db.track_download(user.id)
        
        logger.info(f"‚úÖ DATRIX delivered to user {user.id} ({user.username})")
        
    except Exception as e:
        logger.error(f"Error delivering file to {user.id}: {e}")
        await update.message.reply_text("‚ùå **ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ**\n\nŸäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ•ÿØÿßÿ±ÿ©", parse_mode='Markdown')

# Admin commands
async def set_file_waiting(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to prepare for file upload"""
    if str(update.effective_user.id) != ADMIN_CHAT_ID:
        return
    
    version = context.args[0] if context.args else "v2.1.6"
    
    # Set waiting state
    context.user_data['waiting_for_file'] = True
    context.user_data['file_version'] = version
    
    await update.message.reply_text(
        f"‚úÖ **ÿ¨ÿßŸáÿ≤ ŸÑÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ŸÖŸÑŸÅ DATRIX {version}**\n\n"
        f"üì§ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¢ŸÜ Ÿàÿ≥Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿá ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã",
        parse_mode='Markdown'
    )

async def handle_file_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle file uploads from admin"""
    user_id = str(update.effective_user.id)
    
    # Only admin can upload files
    if user_id != ADMIN_CHAT_ID:
        return
    
    # Check if admin is waiting to upload a file
    if not context.user_data.get('waiting_for_file'):
        return
    
    document = update.message.document
    if not document:
        return
    
    try:
        # Save file info globally
        CURRENT_FILE.update({
            'file_id': document.file_id,
            'version': context.user_data.get('file_version', 'v2.1.6'),
            'size': f"{document.file_size // (1024*1024)}MB" if document.file_size else "Unknown",
            'filename': document.file_name or 'DATRIX_Setup.exe',
            'upload_date': datetime.now().strftime('%Y-%m-%d %H:%M')
        })
        
        # Clear waiting state
        context.user_data['waiting_for_file'] = False
        
        await update.message.reply_text(
            f"‚úÖ **ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ ÿ®ŸÜÿ¨ÿßÿ≠!**\n\n"
            f"üìÑ **ÿßŸÑŸÖŸÑŸÅ:** {CURRENT_FILE['filename']}\n"
            f"üî¢ **ÿßŸÑÿ•ÿµÿØÿßÿ±:** {CURRENT_FILE['version']}\n"
            f"üíæ **ÿßŸÑÿ≠ÿ¨ŸÖ:** {CURRENT_FILE['size']}\n"
            f"üìÖ **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ±ŸÅÿπ:** {CURRENT_FILE['upload_date']}\n\n"
            f"üöÄ **ÿßŸÑŸÖŸÑŸÅ ŸÖÿ™ÿßÿ≠ ÿßŸÑÿ¢ŸÜ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖÿ±ÿÆÿµŸäŸÜ!**",
            parse_mode='Markdown'
        )
        
        logger.info(f"‚úÖ Admin uploaded new file: {CURRENT_FILE['filename']} ({CURRENT_FILE['version']})")
        
    except Exception as e:
        logger.error(f"Error handling file upload: {e}")
        await update.message.reply_text("‚ùå **ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ**", parse_mode='Markdown')

async def current_file_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show current file info (admin only)"""
    if str(update.effective_user.id) != ADMIN_CHAT_ID:
        return
    
    if CURRENT_FILE.get('file_id'):
        info = f"""üìÅ **ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ≠ÿßŸÑŸä:**

üìÑ **ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ:** {CURRENT_FILE['filename']}
üî¢ **ÿßŸÑÿ•ÿµÿØÿßÿ±:** {CURRENT_FILE['version']}
üíæ **ÿßŸÑÿ≠ÿ¨ŸÖ:** {CURRENT_FILE['size']}
üìÖ **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ±ŸÅÿπ:** {CURRENT_FILE['upload_date']}
üÜî **File ID:** `{CURRENT_FILE['file_id'][:20]}...`

‚úÖ **ÿßŸÑÿ≠ÿßŸÑÿ©:** ŸÖÿ™ÿßÿ≠ ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸÖŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖÿ±ÿÆÿµŸäŸÜ"""
    else:
        info = "‚ùå **ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖŸÑŸÅ ŸÖÿ≠ŸÅŸàÿ∏ ÿ≠ÿßŸÑŸäÿßŸã**\n\nÿßÿ≥ÿ™ÿÆÿØŸÖ `/set_file [version]` ÿ´ŸÖ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖŸÑŸÅ ŸÑÿ±ŸÅÿπ ŸÜÿ≥ÿÆÿ© ÿ¨ÿØŸäÿØÿ©"
    
    await update.message.reply_text(info, parse_mode='Markdown')

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show admin statistics"""
    if str(update.effective_user.id) != ADMIN_CHAT_ID:
        return
    
    try:
        stats = db.get_basic_stats()
        
        stats_msg = f"""üìä **ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ DATRIX Bot**

üë• **ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ:**
‚Ä¢ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ: {stats['total_users']}
‚Ä¢ ŸÜÿ¥ÿ∑ (24 ÿ≥ÿßÿπÿ©): {stats['active_users']}
‚Ä¢ ŸÑÿØŸäŸáŸÖ ÿ™ÿ±ÿßÿÆŸäÿµ ŸÜÿ¥ÿ∑ÿ©: {stats['licensed_users']}

üì¶ **ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿßÿ™:**
‚Ä¢ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿßÿ™: {stats['downloads_today']}

üìÅ **ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ≠ÿßŸÑŸä:**
‚Ä¢ ÿßŸÑÿ•ÿµÿØÿßÿ±: {CURRENT_FILE.get('version', 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ')}
‚Ä¢ ÿßŸÑÿ≠ÿßŸÑÿ©: {'‚úÖ ŸÖÿ™ÿßÿ≠' if CURRENT_FILE.get('file_id') else '‚ùå ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠'}

üìÖ **ÿßŸÑÿ™ÿßÿ±ŸäÿÆ:** {datetime.now().strftime('%Y-%m-%d %H:%M')}"""
        
        await update.message.reply_text(stats_msg, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Error getting admin stats: {e}")
        await update.message.reply_text("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if str(update.effective_user.id) == ADMIN_CHAT_ID:
        help_text = """üîß **ÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ¥ÿ±ŸÅ:**

**ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸÑŸÅÿßÿ™:**
‚Ä¢ `/set_file [version]` - ÿ™ÿ≠ÿ∂Ÿäÿ± ŸÑÿ±ŸÅÿπ ŸÖŸÑŸÅ ÿ¨ÿØŸäÿØ
‚Ä¢ `/current_file` - ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ≠ÿßŸÑŸä

**ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™:**
‚Ä¢ `/admin_stats` - ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸÖŸÅÿµŸÑÿ©

**ÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ:**
‚Ä¢ `/start` - ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿ±ÿ≠Ÿäÿ® ŸàÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ
‚Ä¢ `/register_company` - ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ¥ÿ±ŸÉÿ©  
‚Ä¢ `/request_license` - ÿ∑ŸÑÿ® ÿ™ÿ±ÿÆŸäÿµ ÿ¨ÿØŸäÿØ
‚Ä¢ `/my_status` - ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ® ŸàÿßŸÑÿ™ÿ±ÿÆŸäÿµ
‚Ä¢ `/datrix_app` - ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
‚Ä¢ `/help` - ÿπÿ±ÿ∂ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©"""
    else:
        help_text = """ü§ñ **ŸÖÿ≥ÿßÿπÿØÿ© DATRIX Bot**

**ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:**
‚Ä¢ `/start` - ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿ±ÿ≠Ÿäÿ® ŸàÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ
‚Ä¢ `/register_company` - ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿ±ŸÉÿ©
‚Ä¢ `/request_license` - ÿ∑ŸÑÿ® ÿ™ÿ±ÿÆŸäÿµ ÿ¨ÿØŸäÿØ
‚Ä¢ `/my_status` - ÿπÿ±ÿ∂ ÿ≠ÿßŸÑÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ
‚Ä¢ `/datrix_app` - ÿ™ÿ≠ŸÖŸäŸÑ ÿ™ÿ∑ÿ®ŸäŸÇ DATRIX
‚Ä¢ `/help` - ÿπÿ±ÿ∂ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©

**ÿÆÿ∑Ÿàÿßÿ™ ÿßŸÑÿ®ÿØÿ°:**
1. ÿßÿ≥ÿ™ÿÆÿØŸÖ `/register_company` ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¥ÿ±ŸÉÿ™ŸÉ
2. ÿßÿ≥ÿ™ÿÆÿØŸÖ `/request_license` ŸÑÿ∑ŸÑÿ® ÿ™ÿ±ÿÆŸäÿµ
3. ÿ®ÿπÿØ ÿßŸÑŸÖŸàÿßŸÅŸÇÿ©ÿå ÿ≠ŸÖŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿ®ŸÄ `/datrix_app`

**ÿßŸÑŸÖŸÖŸäÿ≤ÿßÿ™:**
‚Ä¢ ‚ö° ÿ™ÿ≠ŸÖŸäŸÑ ŸÅŸàÿ±Ÿä ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÖŸÜ ÿßŸÑÿ®Ÿàÿ™
‚Ä¢ üîê ŸÜÿ∏ÿßŸÖ ÿ™ÿ±ÿßÿÆŸäÿµ ÿ¢ŸÖŸÜ
‚Ä¢ üìä ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ
‚Ä¢ üåê ŸÖÿ™ÿßÿ≠ 24/7

**ÿ™ÿ≠ÿ™ÿßÿ¨ ŸÖÿ≥ÿßÿπÿØÿ©ÿü**
ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ŸÅÿ±ŸäŸÇ ÿßŸÑÿØÿπŸÖ ÿ•ÿ∞ÿß Ÿàÿßÿ¨Ÿáÿ™ ÿ£Ÿä ŸÖÿ¥ÿßŸÉŸÑ."""
    
    await update.message.reply_text(help_text, parse_mode='Markdown')

# =================== MAIN FUNCTION ===================

def main():
    try:
        # Initialize database
        db.initialize_simple_database()
        
        # Create Telegram application
        application = Application.builder().token(BOT_TOKEN).build()
        
        # Add user handlers
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("register_company", register_company))
        application.add_handler(CommandHandler("request_license", request_license))
        application.add_handler(CommandHandler("my_status", my_status))
        application.add_handler(CommandHandler("datrix_app", get_datrix_app))
        application.add_handler(CommandHandler("help", help_command))
        
        # Add admin handlers
        application.add_handler(CommandHandler("set_file", set_file_waiting))
        application.add_handler(CommandHandler("current_file", current_file_info))
        application.add_handler(CommandHandler("admin_stats", admin_stats))
        
        # File upload handler (admin only)
        application.add_handler(MessageHandler(filters.Document.ALL, handle_file_upload))
        
        # Callback handler for license approval
        application.add_handler(CallbackQueryHandler(callback_query_handler))
        
        print("üöÄ DATRIX Bot + Web Dashboard Starting...")
        print(f"ü§ñ Bot Token: {BOT_TOKEN[:10]}...")
        print(f"üë§ Admin ID: {ADMIN_CHAT_ID}")
        print(f"üåê Web User: {WEB_USER}")
        print("‚úÖ System ready!")
        
        # Start bot in a separate process using multiprocessing
        import multiprocessing
        import asyncio
        
        def run_bot_process():
            """Run bot in separate process"""
            try:
                # Create new event loop for this process
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                
                # Run the bot
                application.run_polling(drop_pending_updates=True)
            except Exception as e:
                print(f"‚ùå Bot process error: {e}")
        
        # Start bot process
        bot_process = multiprocessing.Process(target=run_bot_process, daemon=True)
        bot_process.start()
        
        # Start web app in main process
        web_app.run(
            host='0.0.0.0', 
            port=int(os.environ.get('PORT', 8080)),
            debug=False,
            use_reloader=False
        )
        
    except Exception as e:
        logger.error(f"Failed to start: {e}")
        
if __name__ == '__main__':
    main()
